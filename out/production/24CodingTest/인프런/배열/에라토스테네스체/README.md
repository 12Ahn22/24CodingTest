```java
    public static List<Integer> getPrimes(int n){
        boolean [] prime = new boolean[n + 1]; // 계산의 편리함을 위해 + 1
        Arrays.fill(prime, true); // 전부 참으로 초기화

        // 소수는 2부터 시작
        for(int p = 2; p <= Math.sqrt(n); p++){
            if(prime[p]) { // 소수인지 판별하기
                // i가 p*p부터 시작하는 이유
                // - 이미 이전 반복문 때 계산이 되었기 때문에, 중복 계산과 최적화를 위해서
                // - 자기 자신은 제외하기 위해서
                for(int i = p * p; i <= n; i = i + p){
                    prime[i] = false;
                }
            }
        }

        List<Integer> primes = new ArrayList<>();
        for(int i = 2; i <= n; i++){
            if(prime[i]) primes.add(i);
        }

        return primes;
    }
```
### `i`를 `p * p`부터 시작하는 이유
1. **소수의 배수 중 중복 제거:** 
    - 예를 들어, 2의 배수는 4, 6, 8, 10, ... 등이 되는데, 이미 2를 통해 4는 지워졌다,
    - 6, 8, 10... 등의 배수를 다시 검사할 필요가 없다.
    - 그러므로 4부터가 아닌 2의 제곱인 4부터 검사를 시작한다.

2. **남아있는 가장 작은 수를 선택:** 
   - 에라토스테네스의 체 알고리즘은 소수를 하나씩 찾아가는 것이 아니라, 
   - `합성수`를 지우는 방식으로 소수를 찾는다.
     - 합성수 : 1보다 큰 자연수 중에서 소수가 아닌 수로, 약수의 개수가 3개 이상이고 둘 이상의 소수를 곱한 자연수
   - 그래서 제곱부터 시작하여 지워나가면, 남아있는 가장 작은 수가 다음 소수가 되기 때문에 최적화된 방식이다.

3. **제곱근 까지만 나누는 이유**
   - 에라토스테네스의 체는 소수를 구하는 데 사용되는 대표적인 알고리즘 중 하나입니다. 이 알고리즘은 반복적으로 주어진 범위 내의 모든 수를 검사하여 소수인지 여부를 판별.
   - 수의 제곱근 이상의 수는 나누어지는 수가 반드시 제곱근 이하에 존재하기 때문에, 제곱근 이상의 수들을 나누어 소수를 판별하는 것은 불필요한 작업이다.
     - 예를 들어, 100을 예로 들면, 10보다 큰 수로 나누어봤을 때 나머지가 0이 나오는 수는 이미 10보다 작은 수로 나누어봐도 나머지가 0이 나오는 수와 같다. 따라서, 제곱근인 10까지만 나누어보아도 충분히 소수를 판별할 수 있고, 이렇게 하면 계산 시간을 절약할 수 있다.
     따라서, 에라토스테네스의 체에서는 수의 제곱근까지만 계산하여 소수를 판별합니다.