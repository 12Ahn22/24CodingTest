```java
    public static List<Integer> getPrimes(int n){
        boolean [] prime = new boolean[n + 1]; // 계산의 편리함을 위해 + 1
        Arrays.fill(prime, true); // 전부 참으로 초기화

        // 소수는 2부터 시작
        for(int p = 2; p <= n / 2; p++){
            if(prime[p]) { // 소수인지 판별하기
                // i가 p*p부터 시작하는 이유
                // - 이미 이전 반복문 때 계산이 되었기 때문에, 중복 계산과 최적화를 위해서
                // - 자기 자신은 제외하기 위해서
                for(int i = p * p; i <= n; i = i + p){
                    prime[i] = false;
                }
            }
        }

        List<Integer> primes = new ArrayList<>();
        for(int i = 2; i <= n; i++){
            if(prime[i]) primes.add(i);
        }

        return primes;
    }
```
### `i`를 `p * p`부터 시작하는 이유
1. **소수의 배수 중 중복 제거:** 
    - 예를 들어, 2의 배수는 4, 6, 8, 10, ... 등이 되는데, 이미 2를 통해 4는 지워졌다,
    - 6, 8, 10... 등의 배수를 다시 검사할 필요가 없다.
    - 그러므로 4부터가 아닌 2의 제곱인 4부터 검사를 시작한다.

2. **남아있는 가장 작은 수를 선택:** 
   - 에라토스테네스의 체 알고리즘은 소수를 하나씩 찾아가는 것이 아니라, 
   - `합성수`를 지우는 방식으로 소수를 찾는다.
     - 합성수 : 1보다 큰 자연수 중에서 소수가 아닌 수로, 약수의 개수가 3개 이상이고 둘 이상의 소수를 곱한 자연수
   - 그래서 제곱부터 시작하여 지워나가면, 남아있는 가장 작은 수가 다음 소수가 되기 때문에 최적화된 방식이다.